#!/usr/bin/python
# Copyright (c) 2022 Arista Networks, Inc.  All rights reserved.
# Arista Networks, Inc. Confidential and Proprietary.

# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
# * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
# * Redistributions in binary form must reproduce the above copyright notice,  this list of conditions and the following disclaimer in the documentation 
#   and/or other materials provided with the distribution.
# * Neither the name of the Arista nor the names of its contributors may be used to endorse or promote products derived from this software without 
#   specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
# GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
# DAMAGE.

import logging, time, sys
from cvprac.cvp_client import CvpClient
import urllib3
urllib3.disable_warnings()
import json
from copy import deepcopy
import ipaddress
import yaml

TEST_MODE = True
EXPORT_CVP_DATA = True
GENERATE_GENERIC = True


class ipGenerator():
   def __init__(self,subnet="192.168.0.0/24",num_reserved=5):
      self.ip_block = [str(ip) for ip in ipaddress.IPv4Network(subnet)]
      self.ip_block.reverse()

      for x in range(num_reserved+1):
         self.ip_block.pop()

   def get(self):
      return self.ip_block.pop()
   
   def put(self, ip):
      self.ip_block.append(ip)



def build_node_list(inventory, mgmt_ip, log, streaming_active=False):
   '''
   Build a list of EOS nodes, based on the inputs

      Parameters;
         inventory (list): CVP inventory output - a list of dicts containing the standard CVP inventory
         mgmt_ip (ipGenerator): An instance of the ipGenerator class to provide the updated management IPs
         log (logging): Instance of the logger
         streaming_active (bool): Filter out any nodes that aren't actively streaming. Non CVP nodes will still be 
            generated as generic types if the topology requires it

      Returns:
         A list of nodes, a dict of structure {serial:hostname}, and a list of EOS nodes not currently streaming
   '''
   nodeList = []
   serialTable = {}
   blacklist = []
   
   node = {}
   for entry in inventory:
      log.debug('Processing %s', entry['hostname'])
      node[ entry['hostname'] ] = {}
      node[ entry['hostname'] ]['ip_addr'] = mgmt_ip.get()
      node[ entry['hostname'] ]['node_type'] = 'veos'
      node[ entry['hostname'] ]['version'] = entry['version']
      node[ entry['hostname'] ]['neighbors'] = []

      log.debug('Ready to create: %s', entry['hostname'])
      if streaming_active is True:
         if entry['streamingStatus'] != 'active':
            log.warning('Not creating %s as is not currently streaming', entry['hostname'])
            mgmt_ip.put(node[ entry['hostname'] ]['ip_addr'])
            blacklist.append(entry['hostname'])
         else:
            log.debug('Creating node: %s', entry['hostname'])
            nodeList.append(deepcopy(node))
      else:
         nodeList.append(deepcopy(node))
      node.clear()

      serialTable[ entry['serialNumber'] ] = entry['hostname']

   return nodeList,serialTable,blacklist


def generate_edges(raw_topology, serials, mgmt_ip, log, blacklist=[]):
   edgeSet = {}
   extra_nodes = []
   node = {}

   for notification in raw_topology['notifications']:
      for entry in notification['updates']:

         # Assume this to be local serial,local interface, remote serial, remote port
         data = entry.split(',')

         local_hostname = data[0]
         if local_hostname in serials:
            local_hostname = serials[data[0]]
         elif any(remote_hostname in x for x in extra_nodes):
            # Nothing to do, generic node already created
            pass
         else:
            if data[0] not in blacklist:
               log.debug('Creating generic node for %s' % data[0])
               node[local_hostname] = {}
               node[local_hostname]['ip_addr'] = mgmt_ip.get()
               node[local_hostname]['node_type'] = 'generic'
               node[local_hostname]['neighbors'] = []
               extra_nodes.append(deepcopy(node))
               node.clear()
            else:
               log.debug('%s blacklisted - not creating', data[0])

         remote_hostname = data[2]
         if remote_hostname in serials:
            remote_hostname = serials[data[2]]
         else:
            if any(remote_hostname in x for x in extra_nodes):
               # generic node has already been created
               pass
            else:
               log.debug('Remote edge found before local node creation %s %s - %s %s' % (data[0], data[1], data[2], data[3]))

               if remote_hostname not in blacklist:
                  log.debug("Creating generic node: %s" % data[2])
                  node[remote_hostname] = {}
                  node[remote_hostname]['ip_addr'] = mgmt_ip.get()
                  node[remote_hostname]['node_type'] = 'generic'
                  node[remote_hostname]['neighbors'] = []
                  extra_nodes.append(deepcopy(node))
                  node.clear()
               else:
                  log.debug('%s blacklisted - not creating', remote_hostname)

         if local_hostname not in edgeSet:
            edgeSet[local_hostname] = []

         edgeSet[ local_hostname ].append( {'neighborDevice':remote_hostname,'neighborPort':data[3],'port':data[1]  }   )

   return edgeSet, extra_nodes


def main():
   
   timestamp = time.strftime("%Y%m%d-%H%M")
   logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
   mainLogger = logging.getLogger('cvp-atc-exporter')
   # We append to the log if it already exists, if not create the file
   fh = logging.FileHandler('cvp-atc-exporter'+timestamp+'.log', mode='a+')
   # Set the log level going to the file
   fh.setLevel(logging.DEBUG)
   fh.setFormatter(logging.Formatter(fmt='%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
   mainLogger.addHandler(fh)
   ch = logging.StreamHandler(sys.stdout)
   ch.setLevel(logging.INFO)
   ch.setFormatter(logging.Formatter(fmt='%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
   mainLogger.addHandler(ch)
   mainLogger.propagate = False

   mainLogger.info('Script started')



   if TEST_MODE is False:
      mainLogger.info('Attempting to connect to CVP')
      client = CvpClient()
      client.connect(['10.83.13.33'], 'cvpadmin', 'arastra')
      mainLogger.info('Collecting CVP info')
      cvp_info = client.api.get_cvp_info()
      mainLogger.info('Collecting device inventory')
      inventory = client.api.get_inventory()
      mainLogger.info('Collecting link topologies')
      raw_topology = client.get('/api/v1/rest/analytics/network/v1/connections/links')

      if EXPORT_CVP_DATA is True:
         mainLogger.info('Exporting collected data to json')
         json_object = json.dumps(cvp_info,indent=4)
         with open('cvp.json','w') as outfile:
            outfile.write(json_object)

         json_object = json.dumps(inventory,indent=4)
         with open('inventory.json','w') as outfile:
            outfile.write(json_object)

         json_object = json.dumps(raw_topology,indent=4)
         with open('topology.json','w') as outfile:
            outfile.write(json_object)

   else:
      try:
         mainLogger.warning('Running in test mode... Loading local files...')
         with open('cvp.json','r') as openfile:
            cvp_info = json.load(openfile)
         with open('inventory.json','r') as openfile:
            inventory = json.load(openfile)
         with open('topology.json','r') as openfile:
            raw_topology = json.load(openfile)
      except Exception as e:
         mainLogger.error('Unable to open local data: %s', e)
         return 1


   mgmt_ip_block = ipGenerator()

   mainLogger.info("Building node list, and mapping hostname to serial numbers")
   nodes,serialTable,blacklist = build_node_list(inventory, mgmt_ip_block, mainLogger)
   mainLogger.info("Successfully mapped %d nodes, and %d serial numbers", len(nodes), len(serialTable))

   mainLogger.info("Mapping links")
   edgeList, genericNodes = generate_edges(raw_topology,serialTable, mgmt_ip_block, mainLogger, blacklist=blacklist)
   mainLogger.info("Successfully mapped %d links, and found %d generic/not-in-inventory nodes", len(edgeList), len(genericNodes))

   mainLogger.info("Building final datastructure")
   mainLogger.debug("Creating CVP header")
   output_data = {}
   output_data['cvp'] = {}
   output_data['cvp']['username'] = 'root'
   output_data['cvp']['password'] = 'cvproot'
   output_data['cvp']['version'] = cvp_info['version']
   output_data['cvp']['instance'] = 'singleinstance'
   
   mainLogger.debug("Creating generic header")
   output_data['generic'] = {}
   output_data['generic']['version'] = 'CentOS-8-8.2.2004'
   output_data['generic']['username'] = 'ansible'
   output_data['generic']['password'] = 'ansible'

   mainLogger.debug("Populating node list")
   output_data['nodes'] = deepcopy(nodes)
   if GENERATE_GENERIC is True:
      mainLogger.info("Adding generic nodes to inventory")
      output_data['nodes'].extend( deepcopy(genericNodes))

   mainLogger.debug("Adding links to inventory")

   for entry in output_data['nodes']:
      for node in entry:
         if node in edgeList:
            entry[node]['neighbors'] = deepcopy(edgeList[node])
         else:
            mainLogger.debug('%s has no links that we can find', node)

   mainLogger.info('Writing output yaml')
   with open('generated_act_topology.yaml','w') as output_file:
      temp = yaml.safe_dump(output_data, output_file, sort_keys=False)
   mainLogger.info('Export completed')





   return 0


if __name__ == "__main__":
   main()