#!/usr/bin/python
# Copyright (c) 2021 Arista Networks, Inc.  All rights reserved.
# Arista Networks, Inc. Confidential and Proprietary.

# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
# * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
# * Redistributions in binary form must reproduce the above copyright notice,  this list of conditions and the following disclaimer in the documentation 
#   and/or other materials provided with the distribution.
# * Neither the name of the Arista nor the names of its contributors may be used to endorse or promote products derived from this software without 
#   specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
# GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
# DAMAGE.

import logging, time, sys
from cvprac.cvp_client import CvpClient
import urllib3
urllib3.disable_warnings()
import json
from copy import deepcopy
import ipaddress
import yaml

TEST_MODE = True
EXPORT_CVP_DATA = True
GENERATE_GENERIC = False

def build_node_list(inventory):
   nodeList = []
   serialTable = {}
   
   ip_block = [str(ip) for ip in ipaddress.IPv4Network('192.168.0.0/24')]
   ip_block.reverse()

   # No idea what are reserved yet
   for x in range(6):
      ip_block.pop()


   node = {}
   for entry in inventory:
      node[ entry['hostname'] ] = {}
      node[ entry['hostname'] ]['ip_addr'] = ip_block.pop()
      node[ entry['hostname'] ]['node_type'] = 'veos'
      node[ entry['hostname'] ]['version'] = entry['version']
      node[ entry['hostname'] ]['neighbors'] = []

      nodeList.append(deepcopy(node))
      node.clear()

      serialTable[ entry['serialNumber'] ] = entry['hostname']

   return nodeList,serialTable


def generate_edges(raw_topology, serials):
   edgeSet = {}
   extra_nodes = []
   node = {}

   for notification in raw_topology['notifications']:
      for entry in notification['updates']:

         # Assume this to be local serial,local interface, remote serial, remote port
         data = entry.split(',')

         local_hostname = data[0]
         if local_hostname in serials:
            local_hostname = serials[data[0]]
         elif any(remote_hostname in x for x in extra_nodes):
            # Nothing to do, generic node already created
            pass
         else:
            print('Creating extra node for %s' % data[0])
            
            node[local_hostname] = {}
            node[local_hostname]['ip_addr'] = "Unknown"
            node[local_hostname]['node_type'] = 'generic'
            node[local_hostname]['neighbors'] = []
            extra_nodes.append(deepcopy(node))
            node.clear()

         remote_hostname = data[2]
         if remote_hostname in serials:
            remote_hostname = serials[data[2]]
         else:
            if any(remote_hostname in x for x in extra_nodes):
               # generic node has already been created
               pass
            else:
               print('Remote edge found before remote node creation %s %s - %s %s' % (data[0], data[1], data[2], data[3]))
               print("Creating node: %s" % data[2])
               remote_hostname = data[2]
               node[remote_hostname] = {}
               node[remote_hostname]['ip_addr'] = "Unknown"
               node[remote_hostname]['node_type'] = 'generic'
               node[remote_hostname]['neighbors'] = []
               extra_nodes.append(deepcopy(node))
               node.clear()

         if local_hostname not in edgeSet:
            edgeSet[local_hostname] = []

         edgeSet[ local_hostname ].append( {'neighborDevice':remote_hostname,'neighborPort':data[3],'port':data[1]  }   )

   return edgeSet, extra_nodes


def main():
   
   timestamp = time.strftime("%Y%m%d-%H%M%S")
   logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
   mainLogger = logging.getLogger('cvp-atc-exporter')
   # We append to the log if it already exists, if not create the file
   fh = logging.FileHandler('cvp-atc-exporter'+timestamp+'.log', mode='a+')
   # Set the log level going to the file
   fh.setLevel(logging.INFO)
   fh.setFormatter(logging.Formatter(fmt='%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
   mainLogger.addHandler(fh)
   ch = logging.StreamHandler(sys.stdout)
   ch.setLevel(logging.INFO)
   ch.setFormatter(logging.Formatter(fmt='%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
   mainLogger.addHandler(ch)
   mainLogger.propagate = False

   mainLogger.info('Script started')

   mainLogger.info('Attempting to connect to CVP')
   client = CvpClient()
   client.connect(['10.83.13.33'], 'cvpadmin', 'arastra')

   if TEST_MODE is False:
      mainLogger.info('Collecting CVP info')
      cvp_info = client.api.get_cvp_info()
      mainLogger.info('Collecting device inventory')
      inventory = client.api.get_inventory()
      mainLogger.info('Collecting link topologies')
      raw_topology = client.get('/api/v1/rest/analytics/network/v1/connections/links')

      if EXPORT_CVP_DATA is True:
         mainLogger.info('Exporting collected data to json')
         json_object = json.dumps(cvp_info,indent=4)
         with open('cvp.json','w') as outfile:
            outfile.write(json_object)

         json_object = json.dumps(inventory,indent=4)
         with open('inventory.json','w') as outfile:
            outfile.write(json_object)

         json_object = json.dumps(raw_topology,indent=4)
         with open('topology.json','w') as outfile:
            outfile.write(json_object)

   else:
      mainLogger.info('Running in test mode... Loading local files...')
      with open('cvp.json','r') as openfile:
         cvp_info = json.load(openfile)
      with open('inventory.json','r') as openfile:
         inventory = json.load(openfile)
      with open('topology.json','r') as openfile:
         raw_topology = json.load(openfile)         


   mainLogger.info("Building node list, and mapping hostname to serial numbers")
   nodes,serialTable = build_node_list(inventory)
   mainLogger.info("Successfully mapped %d nodes, and %d serial numbers", len(nodes), len(serialTable))

   mainLogger.info("Mapping links")
   edgeList, genericNodes = generate_edges(raw_topology,serialTable)
   mainLogger.info("Successfully mapped %d links, and found %d generic/not-in-inventory nodes", len(edgeList), len(genericNodes))

   mainLogger.info("Building final datastructure")
   mainLogger.debug("Creating CVP header")
   output_data = {}
   output_data['cvp'] = {}
   output_data['cvp']['username'] = 'root'
   output_data['cvp']['password'] = 'cvproot'
   output_data['cvp']['version'] = cvp_info['version']
   output_data['cvp']['instance'] = 'singleinstance'
   
   mainLogger.debug("Creating generic header")
   output_data['generic'] = {}
   output_data['generic']['version'] = 'CentOS-8-8.2.2004'
   output_data['generic']['username'] = 'ansible'
   output_data['generic']['password'] = 'ansible'

   mainLogger.debug("Populating node list")
   output_data['nodes'] = deepcopy(nodes)
   if GENERATE_GENERIC is True:
      mainLogger.info("Adding generic nodes to inventory")
      output_data['nodes'].append( deepcopy(genericNodes))

   mainLogger.debug("Adding links to inventory")

   for entry in output_data['nodes']:
      for node in entry:

         if node in edgeList:
            entry[node]['neighbors'] = deepcopy(edgeList[node])

   with open('generated_act_topology.yaml','w') as output_file:
      temp = yaml.dump(output_data, output_file, sort_keys=False)
   print('READY')





   return 0


if __name__ == "__main__":
   main()